# This shell script emits a C file. -*- C -*-
# It does some substitutions.
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* gld emulation script for NEC SX machines.

   Copyright 2007, 2008 NEC HPCE

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

   Author: Marko Novak <marko.novak@xlab.si>
*/


#define TARGET_IS_${EMULATION_NAME}

#include <string.h>
#include <ctype.h>

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "getopt.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"

#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"

#include "coff/internal.h"
#include "coff/sx.h"
#include "../bfd/libcoff.h"

enum 
	{
		OPTION_SX_OPTION = 300,
		OPTION_SX_SSIZE,
		OPTION_SX_PAGING_MODE,
		OPTION_SX_LAYOUT
	};

/* machine type (i.e. flavour) SX[4|5|6|8]; default is SX5/6 */
static int sx_flavour = bfd_mach_sx5;

/* this flag determines the "Floating-Point Data Type of File Header" 
   (i.e. the "f_flttype" field in the SX COFF header)
   In the 5-3 table of the SX "Programming Language Support Reference Manual",
   its values are defined, as follows:
   * FT_NON: Does not use floating-point data.
   * FT_FL0: Uses float0 mode floating-point data (i.e. the IEEE floating-point
             data format).
   * FT_FL1: Uses float1 mode floating-point data (i.e. the IBM floating-point
             data format).
   * FT_FL2: Uses float2 mode floating-point data (i.e. the CRAY floating-point
             data format).
   * FT_MIX: Uses float0/float1/float2 mode floating-point data format. */
static unsigned char sx_float_mode = FT_FL0;

/* determines if the "the size of size_t type is 64 bits" bit is used. */
static bfd_boolean sx_f3_size_t64 = FALSE;

/* determines whether the program will use small or large virtual memory
	 pages. */
static enum sx_paging_mode_type
{
	SX_PAGING_MODE_SMALL,
	SX_PAGING_MODE_LARGE,
	SX_PAGING_MODE_HUGE
} sx_pg_mode = SX_PAGING_MODE_LARGE;

/* determines memory layout for large pages. this parameter is not used
	 when small pages are selected. */
static enum sx_layout_type
{
	SX_LAYOUT_32G,
	SX_LAYOUT_512G
} sx_layout = SX_LAYOUT_512G;

/* determines the size of stack. The "ssize" field is filled only in the
   "AOUT_MG_LML512" layout, otherwise it has to be 0. */
static bfd_vma sx_ssize = 0x800000000LL;

/* the combination of the "sx_f2_bit6_used" and "" variables determines the 
   mode of the object file:
   1 = object file is in int64 mode (the size of integers is 64 bits). 
   0 = object file is in int32 mode (the size of integers is 32 bits). */
static bfd_boolean sx_f2_bit6_used = FALSE;
static bfd_boolean sx_f2_int64 = FALSE;


/***************** SX linker utility functions********************************/

/* checks if a given string is a number */
inline static bfd_boolean
is_str_number(char *str)
{
  unsigned int i;
  for (i = 0; i < strlen(str); i++)
    {
        if (!isdigit((int)str[i]))
        return FALSE;
    }
    
  return TRUE;
}

static bfd_vma
sx_parse_stack_size(char *str_ssize)
{
  bfd_vma multiplier;
  bfd_vma num_ssize;
  size_t str_len;
  char buff[20];
  bfd_boolean remove_unit;
  const char *end;
  
  /* get the unit (Kilo-, Mega- or Gigabytes)*/
  str_len = strlen(str_ssize);
  if (isdigit((int)*(str_ssize + str_len - 1)))
    {
      /* there is no unit. we are dealing with the number in bytes. */
      multiplier = 1;
      remove_unit = FALSE;
    }
  else if (tolower(*(str_ssize + str_len - 1)) == 'k')
    {
      /* we are dealing with the number in kilobytes. */
      multiplier = 1024;
      remove_unit = TRUE;
    }
  else if (tolower(*(str_ssize + str_len - 1)) == 'm')
    {
      /* we are dealing with the number in megabytes. */
      multiplier = 1024 * 1024;
      remove_unit = TRUE;
    }
  else if (tolower(*(str_ssize + str_len - 1)) == 'g')
    {
      /* we are dealing with the number in gigabytes. */
      multiplier = 1024 * 1024 * 1024;
      remove_unit = TRUE;
    }
  else
    {
      fprintf(stderr, "Invalid stack size unit.");
      return 0;
    }
  
  /* get the stack size in a numerical form. */
  if (remove_unit)
    {
      /* remove the unit sign from the string. */
      strncpy(buff, str_ssize, str_len-1);
      buff[str_len-1] = '\0';
    }
  else
    {
      strcpy(buff, str_ssize);
    }
  num_ssize = bfd_scan_vma(buff, &end, 0);
  
  return (num_ssize * multiplier);
}

/***************** SX linker utility functions END ***************************/

static void
gld${EMULATION_NAME}_add_options
(int ns ATTRIBUTE_UNUSED, char **shortopts ATTRIBUTE_UNUSED, int nl,
 struct option **longopts, int nrl ATTRIBUTE_UNUSED,
 struct option **really_longopts ATTRIBUTE_UNUSED)
{
  static const struct option xtra_long[] = {
    
    { "sx-option", required_argument, NULL, OPTION_SX_OPTION },
    { "sx-stack-size", required_argument, NULL, OPTION_SX_SSIZE },
    { "sx-paging-mode", required_argument, NULL, OPTION_SX_PAGING_MODE },
    { "sx-layout", required_argument, NULL, OPTION_SX_LAYOUT },
    
    {NULL, no_argument, NULL, 0}
  };
  
  *longopts = xrealloc (*longopts,
			nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

#ifdef SX_OBSOLETE_OPTIONS
#define SX_LD_OPTIONS                           \
  "\tsx4, sx5, sx6, sx8, sx9\n"                 \
  "\tsize_t32, size_t64,\n"                     \
  "\tfloat0, float1, float2,\n"                 \
  "\tmaxvl512, vl512\n"                         \
  "\tint64\n"
#define SX_LD_OPTIONS_LONG                                              \
  "\tsx4, sx5, sx6, sx8, sx9: choose target machine type.\n"            \
  "\tfloat0: use float0 mode floating-point data (i.e. the IEEE "       \
  "floating-point data format).\n"                                      \
  "\tfloat1: use float1 mode floating-point data (i.e. the IBM "        \
  "floating-point data format).\n"                                      \
  "\tfloat2: use float2 mode floating-point data (i.e. the CRAY "       \
  "floating-point data format).\n"                                      \
  "\tsize_t32, size_t64: set the size of the 'size_t' type to be \n"    \
  "\t\t32 or 64 bits.\n"                                                \
  "\tmaxvl512: maximum vector register length is 512 elements\n"        \
  "\tvl512: vector register length is 512 elements\n"                   \
  "\tint64: use 64-bit int\n"
#else
#define SX_LD_OPTIONS                           \
  "\tsx6, sx8, sx9\n"                           \
  "\tsize_t32, size_t64,\n"                     \
  "\tmaxvl512, vl512\n"                         \
  "\tint64\n"
#define SX_LD_OPTIONS_LONG                                              \
  "\tsx6, sx8, sx9: choose target machine type.\n"                      \
  "\tsize_t32, size_t64: set the size of the 'size_t' type to be \n"    \
  "\t\t32 or 64 bits.\n"                                                \
  "\tmaxvl512: maximum vector register length is 512 elements\n"        \
  "\tvl512: vector register length is 512 elements\n"                   \
  "\tint64: use 64-bit int\n"
#endif /* SX_OBSOLETE_OPTIONS */

static void
gld${EMULATION_NAME}_list_options (FILE *file)
{
  fprintf(file,
          "  --sx-option=<sx-opt>  "
          "Provide SX assembler option. Supported options:\n"
          SX_LD_OPTIONS_LONG
          );
  fprintf(file, "  --sx-stack-size=<value>  "
          "Set the stack size.\n");  
  fprintf(file, "  --sx-paging-mode={small|large}  "
          "Set the executable to either use the small or\n"
          "\tlarge pages.\n");  
  fprintf(file, "  --sx-layout={32G | 512G}  "
          "Select the memory layout for\n"
          "\tthe executable (large pages only).\n");
}

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  switch (optc)
    {    
    case OPTION_SX_OPTION:
      /* choose flavour. */
#ifdef SX_OBSOLETE_OPTIONS
      if(0 == strcmp(optarg, "sx4"))
        sx_flavour = bfd_mach_sx4;
      else if(0 == strcmp(optarg, "sx5"))
        sx_flavour = bfd_mach_sx5;
      else
#endif /* SX_OBSOLETE_OPTIONS */  
      if(0 == strcmp(optarg, "sx6"))
        sx_flavour = bfd_mach_sx5;
      else if(0 == strcmp(optarg, "sx8"))
        sx_flavour = bfd_mach_sx8;
      else if(0 == strcmp(optarg, "sx9"))
        sx_flavour = bfd_mach_sx9;
      /* choose the size of "size_t" type. */
      else if (0 == strcmp(optarg, "size_t32"))
        sx_f3_size_t64 = FALSE;
      else if (0 == strcmp(optarg, "size_t64"))
        sx_f3_size_t64 = TRUE;
#ifdef SX_OBSOLETE_OPTIONS
      /* choose floating point data format. */
      else if (0 == strcmp(optarg, "float0"))
        sx_float_mode = FT_FL0;     
      else if (0 == strcmp(optarg, "float1"))
        sx_float_mode = FT_FL1;
      else if (0 == strcmp(optarg, "float2"))
        sx_float_mode = FT_FL2;     
#endif /* SX_OBSOLETE_OPTIONS */
      else if (0 == strcmp(optarg, "int64"))
        {
          sx_f2_bit6_used = TRUE;
          sx_f2_int64 = TRUE;
        }
      else
        {
          printf("Invalid SX option: %s. "
                 "Supported options:\n"
                 SX_LD_OPTIONS,
                 optarg);
        }
      break;
    case OPTION_SX_SSIZE:
      sx_ssize = sx_parse_stack_size(optarg);
      break;
    case OPTION_SX_PAGING_MODE:
      if(0 == strcmp(optarg, "small"))
      	sx_pg_mode = SX_PAGING_MODE_SMALL;
      else if (0 == strcmp(optarg, "large"))
        sx_pg_mode = SX_PAGING_MODE_LARGE;
#ifdef SX_HUGE_PAGES
      else if (0 == strcmp(optarg, "huge"))
        sx_pg_mode = SX_PAGING_MODE_HUGE;
#endif /* SX_HUGE_PAGES */
      else
        {
          printf("Invalid SX paging mode: %s. "
                 "Supported modes:\n"
                 "\tsmall, large\n",
                 optarg);
        }
      break;
    case OPTION_SX_LAYOUT:
      if(0 == strcmp(optarg, "32G"))
      	sx_layout = SX_LAYOUT_32G;
      else if (0 == strcmp(optarg, "512G"))
        sx_layout = SX_LAYOUT_512G;
      else
        {
          printf("Invalid SX memory layout: %s. "
                 "Supported layouts:\n"
                 "\t32G, 512G\n",
                 optarg);
        }
      break;     		
    default:
      return FALSE;
    }
  
  return TRUE;
}

static void
gld${EMULATION_NAME}_before_parse (void)
{
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_set_output_arch ("`echo ${ARCH}`", bfd_arch_unknown);
#endif /* not TARGET_ */
}

static short
sx_aout_magic_get(enum sx_paging_mode_type pg_mode, enum sx_layout_type layout)
{
  short aout_magic;
  const int AOUT_ERR = 0;
  
  /* FIXME: implement also the "AOUT_MG_TEXTDATA", "AOUT_MG_LML32MT",
     "AOUT_MG_LMLL512MT" magic numbers. */
  
  if (pg_mode == SX_PAGING_MODE_SMALL)
    aout_magic = AOUT_MG_LMS;
  else if (pg_mode == SX_PAGING_MODE_LARGE)
    {
      if (layout == SX_LAYOUT_32G)
        aout_magic = AOUT_MG_LML32;
      else if (layout == SX_LAYOUT_512G)
        aout_magic = AOUT_MG_LML512;
      else
        {
          printf("Undefined layout for large pages.\n");
          aout_magic = AOUT_ERR;
        }
    }
  else
    {
      printf("Undefined paging mode.\n");
      aout_magic = AOUT_ERR;
    }
  
  return aout_magic;
}


static void
gld${EMULATION_NAME}_set_output_arch(void)
{
  bfd_set_arch_mach (link_info.output_bfd,
                     bfd_get_arch (link_info.output_bfd),
		     sx_flavour);
  
  ldfile_output_architecture = bfd_get_arch (link_info.output_bfd);
  ldfile_output_machine = bfd_get_mach (link_info.output_bfd);
  ldfile_output_machine_name = bfd_printable_name (link_info.output_bfd);
}

static void
gld${EMULATION_NAME}_finish(void)
{
  char tmp_flags;
  
  /* set the magic number for the optional COFF header. */
  coff_data(link_info.output_bfd)->aout_magic = sx_aout_magic_get(sx_pg_mode, sx_layout);
  
  /* set the stack size only for 512G layout. Otherwise set it to 0. */
  if (sx_pg_mode == SX_PAGING_MODE_LARGE && sx_layout == SX_LAYOUT_512G)
    {
      coff_data(link_info.output_bfd)->ssize = sx_ssize;
    }
  else
    {
      coff_data(link_info.output_bfd)->ssize = 0;
    }
  
  /* set the floating point mode. */
  coff_data(link_info.output_bfd)->f_flttype = sx_float_mode;
  
  /* set the "f_flags2" field of COFF header. */
  tmp_flags = coff_data(link_info.output_bfd)->f_flags2;
  if (sx_f2_int64)
    {
      /* the "int64" option can only be used in float2 mode. */
      tmp_flags |= F2_USEB6;
      tmp_flags |= F2_INT64;
    }
  coff_data(link_info.output_bfd)->f_flags2 = tmp_flags;
  
  /* set the "f_flags3" field of COFF header. */
  tmp_flags = coff_data(link_info.output_bfd)->f_flags3;
  if (sx_float_mode == FT_FL0 && sx_f3_size_t64)
    /* the "size_t32", "size_t64" options can only be used in float0 mode. */
    tmp_flags |= F3_SIZE_T64;
  coff_data(link_info.output_bfd)->f_flags3 = tmp_flags;
  
}


static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 0;
  
  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.
  
cat >>e${EMULATION_NAME}.c <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF

fi

cat >>e${EMULATION_NAME}.c <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
	after_parse_default,
  after_open_default,
  after_allocation_default,
  gld${EMULATION_NAME}_set_output_arch,
  ldemul_default_target,
  before_allocation_default,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld${EMULATION_NAME}_finish,
  NULL,	/* create output section statements */
  NULL,	/* open dynamic archive */
  NULL,	/* place orphan */
  NULL,	/* set symbols */
  NULL, /* parse_args */
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  NULL,	/* unrecognised file */
  gld${EMULATION_NAME}_list_options,
  NULL,	/* recognized file */
  NULL,	/* find_potential_libraries */
  NULL	/* new_vers_pattern */
};
EOF
